#!/bin/bash
# Created by Oz Itzkowitz.
# Student code: S10.
# Class TMagen773637.
# Teacher: Erel Regev.

SCRIPT_START_TS=$(date +%s)

# added for tracking tools used in each run.
TOOLS_USED=()

# Define $ for adding color. List taken from previous attempt of a script with @Nick. 
BLACK="\e[30m"
RED="\e[31m"
GREEN="\e[32m"
YELLOW="\e[33m"
BLUE="\e[34m"
MAGENTA="\e[35m"
CYAN="\e[36m"
WHITE="\e[37m"
RESET="\e[0m"

# Bright color options. List taken from chatgpt by request.
BRIGHT_BLACK="\e[90m"
BRIGHT_RED="\e[91m"
BRIGHT_GREEN="\e[92m"
BRIGHT_YELLOW="\e[93m"
BRIGHT_BLUE="\e[94m"
BRIGHT_MAGENTA="\e[95m"
BRIGHT_CYAN="\e[96m"
BRIGHT_WHITE="\e[97m"

# Adding styles. List taken from chatgpt by request.
BOLD="\e[1m"
DIM="\e[2m"
UNDERLINE="\e[4m"
BLINK="\e[5m"
REVERSE="\e[7m"
HIDDEN="\e[8m"

# 1.4 Analysis Menu
# Menu taken from teacher's base script and expanded on it.
function MENU() {
    while true; do
		# Added for breaking the while loop after the multi selection addition.
		should_exit_menu=false
		# MENU Header
		echo -e "${BRIGHT_YELLOW}${BOLD}==========================================================================${RESET}"
        echo -e "${BRIGHT_BLUE}${BOLD}$(figlet -f slant "Here is what's on the MENU")${RESET}"
		echo -e "${BRIGHT_YELLOW}${BOLD}==========================================================================${RESET}"
        echo -e "${YELLOW}Current working file/directory: ${BLUE} ${path:-"Not set"}${RESET}"
        echo -e "${YELLOW}Output directory: ${BLUE} ${OUTPUT_DIR:-"Not set"}${RESET}"
        echo -e "${YELLOW}Current time: ${BLUE} $(date '+%Y-%m-%d %H:%M:%S')${RESET}"
		echo -e "${BRIGHT_YELLOW}${BOLD}==========================================================================${RESET}"
        echo ""
		# MENU List
        echo -e "${YELLOW}[+] 1 - Use bulk_extractor${RESET}" 
        echo -e "${YELLOW}[+] 2 - Use binwalk${RESET}" 
        echo -e "${YELLOW}[+] 3 - Use foremost${RESET}" 
        echo -e "${YELLOW}[+] 4 - Use volatility & extract network traffic${RESET}" 
        echo -e "${YELLOW}[+] 5 - Extract strings & scan for credentials${RESET}" 
        echo -e "${YELLOW}[+] 6 - Use all tools (run everything)${RESET}" 
        echo -e "${YELLOW}[+] 7 - View files created using this script until now${RESET}"
        echo -e "${YELLOW}[+] 8 - remove all files generated by this script ${RESET}"
        echo -e "${YELLOW}[+] 0 - Exit${RESET}"
		# User input.
		echo -e -n "${YELLOW}Enter your choice(s) (${BOLD}ðŸ’¡${RESET}${YELLOW} e.g., 1 3 or 2,4,5): ${RESET}${BLUE}"
		read -r OPTIONS_ALL
		# Clear unwanted from user input, required for multi selection.
		OPTIONS_ALL=($(echo "$OPTIONS_ALL" | tr ',' ' '))
		echo -e "${RESET}"
		
		# Optional used in testing.
		# temp disabled: added timer if non selected run All.
		#		read -t 20 -r OPTIONS
		#       OPTIONS=${menu_choice:-6}

        echo ""
        # Added multi selection option.
		for OPTIONS in "${OPTIONS_ALL[@]}"; do
			# Each number corsponding to MENU list.
			case "$OPTIONS" in
				1)
					start_time=$(date '+%Y-%m-%d %H:%M:%S')
					echo -e "${YELLOW}[1/5] Running bulk_extractor...${RESET}"
					bulk_extractor "$path" -o "$OUTPUT_DIR/bulk_extractor_output" > /dev/null 2>&1
					TOOLS_USED+=("bulk_extractor")
					end_time=$(date '+%Y-%m-%d %H:%M:%S')
					echo -e "${GREEN}${BOLD}âœ…${RESET}${GREEN} bulk_extractor completed | Started: $start_time | Finished: $end_time${RESET}"
					pcap_file=$(find "$OUTPUT_DIR/bulk_extractor_output" -type f -iname "*.pcap" 2>/dev/null | head -n 1)

					if [ -n "$pcap_file" ]; then
						filesize=$(du -h "$pcap_file" | cut -f1)
						echo -e "${YELLOW}ðŸ“¡ Network traffic file detected!${RESET}"
						echo -e "${YELLOW}ðŸ“‚ Location: ${BLUE} $pcap_file${RESET}"
						echo -e "${YELLOW}ðŸ“¦ Size: ${BLUE} $filesize${RESET}"

						echo -en "${YELLOW}ðŸ” Would you like to open the network file with Wireshark? (y/n): ${RESET}"
						read -t 10 -r open_choice

						if [[ "$open_choice" =~ ^[Yy]$ ]]; then
							if command -v wireshark > /dev/null 2>&1; then
								echo -e "${GREEN}Launching Wireshark...${RESET}"
								wireshark "$pcap_file" &
							else
								echo -e "${RED}âŒ Wireshark is not installed or or not answered in time.${RESET}"
							fi
						fi
					fi
					;;

				2)
					start_time=$(date '+%Y-%m-%d %H:%M:%S')
					echo -e "${YELLOW}[2/5] Running binwalk...${RESET}"
					info_dir="$OUTPUT_DIR/binwalk_output"
					mkdir -p "$info_dir"
					
					sudo binwalk "$path" > "$info_dir/binwalk_info.txt" 2>/dev/null
					TOOLS_USED+=("binwalk")
					echo -e "${GREEN}${BOLD}âœ…${RESET}${GREEN} binwalk info saved to: ${BLUE} $info_dir/binwalk_info.txt${RESET}"
					echo -e "${YELLOW}would you like to view the binwalk info? (y/n)${RESET}"
					read -t 15 -r binwalk_view
					
					if [[ "$binwalk_view" =~ ^[Yy]$ ]]; then
						cat "$info_dir/binwalk_info.txt"
					else
						echo ""
					fi
					
					echo -e "${YELLOW}should i extract using binwalk? (y/n) (can take a long time depending on file size)${RESET}"
					read -t 15 -r binwalk_extract
					
					if [[ "$binwalk_extract" =~ ^[Yy]$ ]]; then
						
						TOOL_NAME="binwalk"
						echo -e "${BLUE}[$step_count/$total_steps] running $TOOL_NAME...${RESET}"

						# Run binwalk extraction
						sudo binwalk -e --run-as=root "$path" > /dev/null 2>&1
					
						# Define expected extraction directory
						extracted_dir="_$(basename "$path").extracted"
						binwalk_dir="$OUTPUT_DIR/binwalk"
						

						# Move extracted directory if it exists
						if [ -d "$extracted_dir" ]; then
							mkdir -p "$binwalk_dir"
							mv "$extracted_dir" "$binwalk_dir"
						else
							echo -e "${YELLOW}âš ï¸ binwalk extraction directory not found: ${BLUE} $extracted_dir${RESET}"
							echo ""
						fi
					else
						echo ""
					fi
					end_time=$(date '+%Y-%m-%d %H:%M:%S')
					echo -e "${GREEN}${BOLD}âœ…${RESET}${GREEN} binwalk completed | Started: $start_time | Finished: $end_time${RESET}"
					;;

				3)
					start_time=$(date '+%Y-%m-%d %H:%M:%S')
					echo -e "${YELLOW}[3/5] Running foremost...${RESET}"
					foremost -i "$path" -o "$OUTPUT_DIR/foremost_output" > /dev/null 2>&1
					TOOLS_USED+=("foremost")
					end_time=$(date '+%Y-%m-%d %H:%M:%S')
					echo -e "${GREEN}${BOLD}âœ…${RESET}${GREEN}foremost completed | Started: $start_time | Finished: $end_time${RESET}"
					;;

				4)
					start_time=$(date '+%Y-%m-%d %H:%M:%S')
					echo -e "${YELLOW}[4/5] Running Volatility...${RESET}"
					RUN_VOLATILITY
					TOOLS_USED+=("Volatility")
					end_time=$(date '+%Y-%m-%d %H:%M:%S')
					echo -e "${GREEN}${BOLD}âœ…${RESET}${GREEN}Volatility completed | Started: $start_time | Finished: $end_time${RESET}"
					;;

				5)
					start_time=$(date '+%Y-%m-%d %H:%M:%S')
					echo -e "${YELLOW}[5/5] Extracting strings and scanning for credentials...${RESET}"
					CHECK_HUMAN_READABLE
					TOOLS_USED+=("Strings")
					end_time=$(date '+%Y-%m-%d %H:%M:%S')
					echo -e "${GREEN}${BOLD}âœ…${RESET}${GREEN} String analysis completed | Started: $start_time | Finished: $end_time${RESET}"
					;;

				6)
					# Run all option.
					echo -e "${BRIGHT_YELLOW}Running all forensic tools...${RESET}"
					overall_start=$(date '+%Y-%m-%d %H:%M:%S')
					total_steps=5
					step_count=0

					# Step 1: bulk_extractor
					((step_count++))
					TOOL_NAME="bulk_extractor"
					echo -e "${YELLOW}[$step_count/$total_steps] running $TOOL_NAME...${RESET}"

					bulk_extractor "$path" -o "$OUTPUT_DIR/bulk_extractor_output" > /dev/null 2>&1
					TOOLS_USED+=("bulk_extractor")
					echo -e "${GREEN}${BOLD}âœ…${RESET}${GREEN}bulk_extractor completed. Output saved to: ${BLUE} $OUTPUT_DIR/bulk_extractor_output${RESET}"

					
					# Save binwalk scan results
					((step_count++))
					TOOL_NAME="binwalk"
					echo -e "${YELLOW}[$step_count/$total_steps] running $TOOL_NAME...${RESET}"
					
					info_dir="$OUTPUT_DIR/binwalk_output"
					mkdir -p "$info_dir"
					
					sudo binwalk --run-as=root "$path" > "$info_dir/binwalk_info.txt" 2>/dev/null
					TOOLS_USED+=("binwalk")
					
					echo -e "${GREEN}${BOLD}âœ…${RESET}${GREEN} binwalk info saved to: ${BLUE} $info_dir/binwalk_info.txt${RESET}"
					echo -e "would you like to view the binwalk info? (y/n)"
					read -t 15 -r binwalk_view
					
					if [[ "$binwalk_view" =~ ^[Yy]$ ]]; then
						cat "$info_dir/binwalk_info.txt"
					else
						echo ""
					fi
					
					echo -e "${YELLOW}should i extract using binwalk? (y/n) (can take a long time depending on file size)${RESET}"
					read -t 15 -r binwalk_extract
					
					if [[ "$binwalk_extract" =~ ^[Yy]$ ]]; then
						
						# Run binwalk extraction
						sudo binwalk -e --run-as=root "$path" > /dev/null 2>&1
					
						# Define expected extraction directory
						extracted_dir="_$(basename "$path").extracted"
						binwalk_dir="$OUTPUT_DIR/binwalk"
						

						# Move extracted directory if it exists
						if [ -d "$extracted_dir" ]; then
							mkdir -p "$binwalk_dir"
							mv "$extracted_dir" "$binwalk_dir"
						else
							echo -e "${YELLOW}âš ï¸ binwalk extraction directory not found: ${BLUE} $extracted_dir${RESET}"
							echo ""
						fi
					else
						echo ""
					fi
					
					# Step 3: foremost
					((step_count++))
					TOOL_NAME="foremost"
					echo -e "${YELLOW}[$step_count/$total_steps] running $TOOL_NAME${RESET}"
					foremost -i "$path" -o "$OUTPUT_DIR/foremost_output" > /dev/null 2>&1
					TOOLS_USED+=("foremost")
					
					# Step 4: Volatility
					((step_count++))
					TOOL_NAME="Volatility"
					echo -e "${YELLOW}[$step_count/$total_steps] running $TOOL_NAME${RESET}"
					RUN_VOLATILITY
					TOOLS_USED+=("Volatility")

					# Step 5: string extraction
					((step_count++))
					TOOL_NAME="string extraction"
					echo -e "${YELLOW}[$step_count/$total_steps] running $TOOL_NAME${RESET}"
					CHECK_HUMAN_READABLE
					TOOLS_USED+=("Strings")

					overall_end=$(date '+%Y-%m-%d %H:%M:%S')
					echo ""
					echo -e "${GREEN}${BOLD}âœ… All forensic tools completed successfully! ${RESET}"
					echo -e "${GREEN}${BOLD} Overall process | Started: $overall_start | Finished: $overall_end ${RESET}"
					echo -e "${YELLOW}${BOLD} All outputs saved to: ${RESET}${BLUE} $OUTPUT_DIR ${RESET}"
					break
					;;
		
				7)
					# Added for user to have easy view of files & folders created. 
					tree "$OUTPUT_DIR"
					;;
			   
				8)
					# Optional for easy clean up.
					CLEANUP_AFTER
					;;
				0)
					echo -e "${RED}Exiting...${RESET}"
					should_exit_menu=true
					break
					;;

				*)
					echo -e "${RED}${BOLD}âŒ${REST} ${RED}Invalid option. Please try again.${RESET}"
					;;
			esac
		done
			# this breaks the while loop (exits the menu)
			if [ "$should_exit_menu" = true ]; then
				break  
			fi
        echo ""
       
    done
}

# define apps to be used in script & check if they are installed, if not run install or download for vol2.5.
function CHECK_APPS() {
# app list for the script.	
    apps=("figlet" "tree" "bulk_extractor" "binwalk" "foremost" "volatility" "strings")
    echo -e "${BRIGHT_YELLOW}Checking required forensic tools...${RESET}"
    
# define apps and set current.     
    total_apps=${#apps[@]}
    current_app=0
    
# loop apps from above.
    for app in "${apps[@]}"; do
        ((current_app++))
        echo -e "${BRIGHT_YELLOW}Progress: [$current_app/$total_apps] Checking $app...${RESET}"
        
# using command -v for more OS systems compatibility.
        if command -v "$app" > /dev/null 2>&1; then
            echo -e "${BRIGHT_GREEN}${BOLD}âœ…${RESET}${GREEN} $app is already installed. Skipping.${RESET}"
        else
        
#app install.        
            echo -e "${BRIGHT_RED}${BOLD}âŒ${RESET}${RED} $app is not installed. Installing...${RESET}"
            case "$app" in
                bulk_extractor)
                    sudo apt install bulk-extractor -y > /dev/null 2>&1 ;;
                binwalk)
                    sudo apt install binwalk -y > /dev/null 2>&1 ;;
                foremost)
                    sudo apt install foremost -y > /dev/null 2>&1 ;;
                volatility)
                    INSTALL_VOLATILITY ;;
                strings)
                    sudo apt install binutils -y > /dev/null 2>&1 ;;
                figlet)
                    sudo apt install figlet -y > /dev/null 2>&1 ;;
                tree)
					sudo apt install tree -y > /dev/null 2>&1 ;;
			esac
        fi
    done
echo -e "${BRIGHT_GREEN}${BOLD}âœ… ${RESET}${BRIGHT_GREEN} All required tools are checked and ready.${RESET}"
echo ""

# Stylized Banner with figlet.
echo -e "${BRIGHT_BLUE}${BOLD}"
figlet -f slant "Forensics"
figlet -f slant "Investigation"
echo -e "${RESET}"

echo -e "${BRIGHT_MAGENTA}${BOLD}"
figlet -f slant "Project:"
echo -e "${BRIGHT_MAGENTA}${BOLD}${BLINK}"
figlet -f slant "Analyzer"
echo -e "${RESET}"

# Proceed to menu.
MENU
}

#1 check if user=0=root, if not exit.
function START() {
    if [ "$(id -u)" -ne 0 ]; then
		echo -en "${RED}${BOLD}âŒ  User is NOT root,${RESET}"
        echo -e "    ${RED}${BOLD}${UNDERLINE}This script must be run as root. Exiting.${RESET}"
        exit 1
    else
		echo -e "${GREEN}${BOLD}âœ…${RESET}${GREEN} User is: root ${RESET}"
		# Run CHECK_APPS
        CHECK_APPS
    fi
    
}

#2 Allow user to specify file as argument, check if there is a file & file is not empty.
function FILE_CHECK() {
    path="$1"

    if [ -z "$path" ]; then
        echo ""
        echo -e "${BRIGHT_RED}${BOLD}âŒ No file path provided. Please run the script with the memory image path as an argument.${RESET}"
        echo ""
        echo -e "${BRIGHT_YELLOW}${BOLD}Usage: ./volfinal.sh /path/to/memory.img${RESET}"
        exit 1
    fi

#2.1 check if file is one of the below (fit for volatility or type of image)
    if [[ ! "$path" =~ \.(raw|dd|img|bin|mem|vmem)$ ]]; then
        echo -e "${YELLOW}âš ï¸  Warning: File extension is uncommon or may not be supported for memory analysis.${RESET}"
    fi
#2.0 second part check not empty & define as varibale. (clear name for the usage)
    if [ -f "$path" ] && [ -s "$path" ]; then
        echo -e "${GREEN}${BOLD}âœ…${RESET}${GREEN} File exists and is not empty: ${BLUE} $path${RESET}"
        FILE_NAME=$(basename "$path")
        FILE_NAME="${FILE_NAME%.*}"
        OUTPUT_DIR="$FILE_NAME"
        mkdir -p "$OUTPUT_DIR"
        START
    else
        echo -e "${RED}${BOLD}âŒ File does not exist or is empty. Please check the path and try again.${RESET}"
        exit 1
    fi
}
# Curl the vol 2.5 file if needed from google drive, kept older version below commented out. using curl for the cleaner interface in terminal.
function INSTALL_VOLATILITY() {
		# Check if ./vol file is in the current directory.
		if [ -f "./vol" ]; then
			echo -e "${GREEN}${BOLD}âœ… ${RESET}${GREEN}Volatility is not installed but portable version is already in the current directory: try ./vol ${RESET}"
		else
		
# Required by google drive:
			FILEID="1bEWigKHFLNhPDKbaUlfV3RpZs9XF2nmY"
			FILENAME="vol"

			echo -e "${GREEN}Downloading Volatility...${RESET}"

# Get confirmation token and download using curl (Google Drive workaround).
			CONFIRM=$(curl -sc /tmp/gcookie "https://drive.google.com/uc?export=download&id=${FILEID}" | \
					  grep -o 'confirm=[^&]*' | cut -d= -f2)

			curl -Lb /tmp/gcookie "https://drive.google.com/uc?export=download&confirm=${CONFIRM}&id=${FILEID}" \
				-o "$FILENAME"
				
# Add executable.
			chmod +x "$FILENAME"
			echo -e "${GREEN}${BOLD}âœ… Volatility 2.5 downloaded and made executable.${RESET}"
			echo ""
		fi
}
# Older version of downloading vol 2.5 via google drive using wget.
# not used becasue of more output in terminal. 
#
#function INSTALL_VOLATILITY() {
#    FILEID=1bEWigKHFLNhPDKbaUlfV3RpZs9XF2nmY
#  	 FILENAME=vol
#
#    echo -e "${CYAN}Downloading Volatility...${RESET}"
#    wget --quiet --progress=bar:force "https://docs.google.com/uc?export=download&id=${FILEID}" -O ${FILENAME} 2>&1
#
#    chmod +x vol
#    echo -e "${GREEN}${BOLD}âœ… Volatility 2.5 installed & ready${RESET}"
#    echo ""
#}

# Running volatility.
function RUN_VOLATILITY() {
    echo -e "${YELLOW}[*] Checking if the file can be analyzed with Volatility 2.5...${RESET}"
	# Get profile, and check if file can be run in Vol 2.5.
    PROFILE_OUTPUT=$(sudo ./vol -f "$path" imageinfo 2>/dev/null)
    PROFILE=$(echo "$PROFILE_OUTPUT" | grep "Suggested Profile" | cut -d ":" -f2 | cut -d "," -f1 | xargs)

    if [ -z "$PROFILE" ]; then
        echo -e "${RED}âŒ Volatility could not determine a suggested profile.${RESET}"
        echo -e "${YELLOW}âš ï¸  Skipping Volatility 2.5 analysis. File may be incompatible or corrupted.${RESET}"
        return
    fi

    echo -e "${GREEN}${BOLD}âœ…${RESET}${GREEN} Detected profile: ${BLUE}$PROFILE${RESET}"
    echo -e "${GREEN}Proceeding with Volatility analysis...${RESET}"

# Set output dir for VOL files.
    VOL_DIR="$OUTPUT_DIR/vol_$PROFILE"
    mkdir -p "$VOL_DIR"

# Changed older version for more user interaction & get what you need not just $All.
# Can now decide on a specific plugin to run or all.    
	while true;do

		echo -e "${YELLOW}====================== Volatility Plugin Menu ======================${RESET}"
		echo -e "${YELLOW}[1] Run specific plugin${RESET}"
		echo -e "${YELLOW}[2] Run all plugins${RESET}"
		echo -e "${YELLOW}[0] Exit${RESET}"
		echo -e "${YELLOW}====================================================================${RESET}"
		
		echo -e "${YELLOW}Enter your choice: ${RESET}"
		
# added timer for user input. if non selected run All
		read -t 20 -r menu_choice

# check if menu_choice is empty after timer.
		if [ -z "$menu_choice" ]; then
			echo -e "\n${YELLOW}${BOLD}â±ï¸ No input detected. Defaulting to 'Run all plugins'.${RESET}"
			menu_choice=2
		fi

# plugins I think are usefull,  others can be added.
		PLUGINS=("clipboard" "cmdline" "cmdscan" "consoles" "dlllist" "driverscan" "filescan" "getservicesids" "getsids" \
				 "handles" "hivelist" "iehistory" "memmap" "mftparser" "netscan" "pslist" "psscan" "pstree" "psxview" "svcscan" \
				 "userassist" "windows" "hashdump" "shutdowntime")
		
# Chatgpt suggested a shorter version from the list made by me via "case", define *loop single in plugin, *All, *exit. 
# this runs same as previous code just shorter and more dynamic.
		case "$menu_choice" in
			1)
				#Define single in plugin. list all and add selection option. 
				echo -e "${YELLOW}Available plugins:${RESET}"
				# List the plugins from above with numbers.
				for i in "${!PLUGINS[@]}"; do
					echo -e "${YELLOW}[$((i + 1))] ${PLUGINS[$i]}${RESET}"
				done
				# user input.
				echo -en "${YELLOW}Enter plugin number to run: ${RESET}"
				read -r plugin_index
				# check if the number given by user match the plugin list, if it is, runs plugin, else error.
				if [[ "$plugin_index" =~ ^[0-9]+$ && "$plugin_index" -ge 1 && "$plugin_index" -le ${#PLUGINS[@]} ]]; then
					# change back to 0-base.index 
					plugin="${PLUGINS[$((plugin_index - 1))]}"
					echo -e "${BRIGHT_YELLOW}[*] Running ${BOLD}${plugin}...${RESET}"
					sudo ./vol -f "$path" --profile="$PROFILE" "$plugin" --output-file="$VOL_DIR/${plugin}.txt" > /dev/null 2>&1
					
					# Decided on the below could be usefull.
					# if hivelist then dump the hive files. helped by chatgpt to implement.
					if [ "$plugin" == "hivelist" ]; then
						echo -e "${YELLOW}[*] Extracting all registry hives using ${BOLD} hivelist + dumpregistry...${RESET}"
						sudo ./vol -f "$path" --profile="$PROFILE" hivelist > "$VOL_DIR/hivelist.txt"

						# Directory for .reg dumps
						REGISTRY_HIVE_DUMP="$VOL_DIR/REGISTRY_HIVES"
						mkdir -p "$REGISTRY_HIVE_DUMP"
						# get virtual address from hivelist.txt then run for each line. 
						grep '^0x' "$VOL_DIR/hivelist.txt" | while read -r line; do
							VIRTUAL=$(echo "$line" | awk '{print $1}')
							echo -e "${YELLOW}[*] Dumping hive at virtual offset ${BOLD} $VIRTUAL...${RESET}"
							sudo ./vol -f "$path" --profile="$PROFILE" dumpregistry -o "$VIRTUAL" --dump-dir "$VOL_DIR" > /dev/null
						done

						# Move all .reg files to the registry dump folder
						find "$VOL_DIR" -maxdepth 1 -type f -name "*.reg" -exec mv {} "$REGISTRY_HIVE_DUMP" \;

						echo -e "${GREEN}${BOLD}âœ…${RESET}${GREEN} All dumped .reg files moved to: ${BLUE}$REGISTRY_HIVE_DUMP${RESET}"
					
					# if shutdown: show info.
					elif [ "$plugin" = "shutdowntime" ]; then
						echo -e "${YELLOW}Shutdown time results:${RESET}"
						cat "$VOL_DIR/${plugin}.txt"
				
					# if pslist: show info.		
					elif [ "$plugin" = "pslist" ]; then
						echo -e "${YELLOW}pslist results:${RESET}"
						cat "$VOL_DIR/${plugin}.txt"
				
					# if netscan: show info.	
					elif [ "$plugin" = "netscan" ]; then
							if [ -s "$NETWORK_FILE" ]; then
								SIZE=$(du -h "$NETWORK_FILE" | cut -f1)
								echo -e "${YELLOW}netscan results:${RESET}"
								cat "$VOL_DIR/${plugin}.txt"			
							fi
										
					# If hashdump then auto crack via john using rockyou.txt, if already cracked use --show --format=NT. 	
					elif [ "$plugin" = "hashdump" ]; then
							HASH_FILE="$VOL_DIR/hashdump.txt"
							CRACKED_FILE="$VOL_DIR/cracked_file.txt"
						if [ -s "$HASH_FILE" ]; then
							SIZE=$(du -h "$HASH_FILE" | cut -f1)
							cracked_output=$(john --show --format=NT "$HASH_FILE" 2>/dev/null)

						
							 if [[ -n "$cracked_output" && "$cracked_output" != *"0 password hashes cracked"* ]]; then
								echo -e "${GREEN}${BOLD}âœ…${RESET}${GREEN} Previously cracked hashes found:${RESET}"
								echo -e "$cracked_output"
								echo -e "$cracked_output" > "$CRACKED_FILE"
							else
								echo -e "${YELLOW} Attempting to crack hashes...${RESET}"
								john "$HASH_FILE" --format=NT --wordlist=/usr/share/wordlists/rockyou.txt > /dev/null
								echo -e "${GREEN}${BOLD}âœ… ${RESET}${GREEN}Crack complete. Cracked hashes:${RESET}"
								john --show --format=NT "$HASH_FILE"
								john --show --format=NT "$HASH_FILE" > "$CRACKED_FILE"
							fi
						fi
					else
						echo -e "${RED}Invalid selection.${RESET}"
					fi
				fi
				;;

			2)
				# Run All
				for plugin in "${PLUGINS[@]}"; do
					echo -e "${BRIGHT_YELLOW}[*] Running ${BOLD}${plugin}...${RESET}"
					./vol -f "$path" --profile="$PROFILE" "$plugin" --output-file="$VOL_DIR/${plugin}.txt" > /dev/null 2>&1
					
					if [ "$plugin" == "hivelist" ]; then
						echo -e "${YELLOW}[*] Extracting all registry hives using hivelist + dumpregistry...${RESET}"
						sudo ./vol -f "$path" --profile="$PROFILE" hivelist > "$VOL_DIR/hivelist.txt"

						# Directory for .reg dumps
						REGISTRY_HIVE_DUMP="$VOL_DIR/REGISTRY_HIVES"
						mkdir -p "$REGISTRY_HIVE_DUMP"

						grep '^0x' "$VOL_DIR/hivelist.txt" | while read -r line; do
							VIRTUAL=$(echo "$line" | awk '{print $1}')
							echo -e "[*] Dumping hive at virtual offset $VIRTUAL..."
							sudo ./vol -f "$path" --profile="$PROFILE" dumpregistry -o "$VIRTUAL" --dump-dir "$VOL_DIR" > /dev/null
						done

						# Move all .reg files to the registry dump folder
						find "$VOL_DIR" -maxdepth 1 -type f -name "*.reg" -exec mv {} "$REGISTRY_HIVE_DUMP" \;

						echo -e "${GREEN}${BOLD}âœ… ${RESET}${GREEN}All dumped .reg files moved to: ${BLUE}$REGISTRY_HIVE_DUMP${RESET}"

					elif [ "$plugin" = "shutdowntime" ]; then
						echo -e "${YELLOW}Shutdown time results:${RESET}"
						cat "$VOL_DIR/${plugin}.txt"
						
					elif [ "$plugin" = "pslist" ]; then
						echo -e "${YELLOW}pslist results:${RESET}"
						cat "$VOL_DIR/${plugin}.txt"
						
					elif [ "$plugin" = "netscan" ]; then
							if [ -s "$NETWORK_FILE" ]; then
								SIZE=$(du -h "$NETWORK_FILE" | cut -f1)
								echo -e "${YELLOW}netscan results:${RESET}"
								cat "$VOL_DIR/${plugin}.txt"			
							else
								echo ""
							fi
						
					elif [ "$plugin" = "hashdump" ]; then
						HASH_FILE="$VOL_DIR/hashdump.txt"
						CRACKED_FILE="$VOL_DIR/cracked_file.txt"

						cracked_output=$(john "$HASH_FILE" --show --format=NT 2>/dev/null)

						if [[ -n "$cracked_output" && "$cracked_output" != *"0 password hashes cracked"* ]]; then
							echo -e "${GREEN}${BOLD}âœ…${RESET}${GREEN} Previously cracked hashes found:${RESET}"
							echo -e "$cracked_output"
							echo -e "$cracked_output" > "$CRACKED_FILE"
						else
							echo -e "${YELLOW} Attempting to crack hashes...${RESET}"
							john "$HASH_FILE" --format=NT --wordlist=/usr/share/wordlists/rockyou.txt > /dev/null
							echo -e "${GREEN}${BOLD}âœ…${RESET}${GREEN} Crack complete. Cracked hashes:${RESET}"
							john "$HASH_FILE" --show --format=NT "$HASH_FILE"
							john "$HASH_FILE" --show --format=NT > "$CRACKED_FILE"
						fi
					fi
				done
				break
				;;

			0)
				echo -e "${CYAN}Exiting.${RESET}"
				return
				;;

			*)
				echo -e "${RED}Invalid option. Please choose again.${RESET}"
				;;
		esac
	done
# Inform user status & location 
    echo -e "${GREEN}${BOLD}âœ…${RESET}${GREEN} Volatility analysis completed for ${BLUE} $PROFILE.${RESET}"
    echo -e "${YELLOW}All scan files saved in: ${BLUE} $VOL_DIR ${RESET}"

# Show netscan results if found.
    NETSCAN_FILE="$VOL_DIR/netscan.txt"
    EXTRACT_NETWORK_TRAFFIC "$NETSCAN_FILE"
}

# Network file is not empty, show network file & search .pcap file and show options.
function EXTRACT_NETWORK_TRAFFIC() {
    NETWORK_FILE="$1"
    if [ -s "$NETWORK_FILE" ]; then
        SIZE=$(du -h "$NETWORK_FILE" | cut -f1)
        echo -e "${GREEN}${BOLD}âœ… ${RESET}${GREEN}Network traffic using netscan saved to: ${BLUE} $NETWORK_FILE ($SIZE)${RESET}"
    else
        echo -e "${BRIGHT_RED}${BOLD}âŒ No network traffic found using netscan.${RESET}"
    fi
    
# Look for .pcap file this will only run if bulk_extraction was perviuosly used.
	pcap_file=$(find "$OUTPUT_DIR/bulk_extractor_output" -type f -iname "*.pcap" 2>/dev/null | head -n 1)

	if [ -n "$pcap_file" ]; then
		filesize=$(du -h "$pcap_file" | cut -f1)
		echo -e "${YELLOW}ðŸ“¡ Network traffic file detected!${RESET}"
		echo -e "${YELLOW}ðŸ“‚ Location: ${BLUE}$pcap_file${RESET}"
		echo -e "${YELLOW}ðŸ“¦ Size: ${BLUE}$filesize${RESET}"
		# user option to view found PCAP.
		echo -en "${YELLOW}ðŸ” Would you like to open the network file with Wireshark? (y/n): ${RESET}"
		read -t 15 -r open_choice
		
# Check wireshark.
		if [[ "$open_choice" =~ ^[Yy]$ ]]; then
			if command -v wireshark > /dev/null 2>&1; then
				echo -e "${GREEN}${BOLD}ðŸš€ Launching Wireshark...${RESET}"
				wireshark "$pcap_file" &
			else
				echo -e "${RED}${BOLD}âŒ Wireshark is not installed or no answer in time. ${RESET}"
			fi
		fi
	fi
}

# 1.7 Scan for strings and look for credentials
function CHECK_HUMAN_READABLE() {
	STRINGS_DIR="$OUTPUT_DIR/STRINGS"
	CREDS_DIR="$STRINGS_DIR/CREDS"
	STRINGS_FILE="$STRINGS_DIR/strings.txt"

	mkdir -p "$CREDS_DIR"

    echo -e "${YELLOW}[*] Extracting readable strings from memory...${RESET}"
    # chatGPT suggest -n 6 to avoid error in strings smaller then 6.
    strings -n 6 "$path" > "$STRINGS_FILE"
	# List of grep I want, can be modefied here.
	GREP_FLAG=("password" "passwd" "login" "username" "user" "credential" "token" "auth" "secret" "key")
	
	echo -e "${YELLOW}[*] Searching for credential-related strings...${RESET}"
	echo -e "${YELLOW} grep running to find possible creds ${RESET}"
	# run grep for each of the keywords above.
	for flag in "${GREP_FLAG[@]}"; do
		grep -i "$flag" "$STRINGS_FILE" > "$CREDS_DIR/$flag.txt" 2>/dev/null
		# Remove empty files
		[ ! -s "$CREDS_DIR/$flag.txt" ] && rm -f "$CREDS_DIR/$flag.txt"
	done

    echo -e "${GREEN}${BOLD}âœ… ${RESET}${GREEN} Strings saved to:${BLUE} $STRINGS_FILE ${RESET}"
    
	if [ -n "$(ls -A $CREDS_DIR 2>/dev/null)" ]; then
		COUNT=$(cat "$CREDS_DIR"/* | wc -l)
		echo -e "${GREEN}${BOLD}âœ… ${RESET}${GREEN} Found $COUNT potential credential matches in: ${BLUE} $CREDS_DIR ${RESET}"
	else
		echo -e "${RED}${BOLD}âŒ No obvious credentials found.${RESET}"
		rm -rf "$CREDS_DIR"
	fi
}

# Allow auto remove all created files & dir.
function CLEANUP_AFTER() {
    while true; do
        echo -e "${CYAN}[i] Output directory: ${BLUE} $OUTPUT_DIR${RESET}"
        echo ""
		echo -e "${RED}${BOLD}âš ï¸  WARNING: This will permanently delete all extracted analysis files.${RESET}"
		echo -ne "${YELLOW}Should I delete all extracted files & folders? (yes / no): ${RESET}"
		read -r CLEAN_UP
		CLEAN_UP=$(echo "$CLEAN_UP" | tr '[:upper:]' '[:lower:]')
		
        case "$CLEAN_UP" in
            yes)
                start_time=$(date '+%Y-%m-%d %H:%M:%S')
                if [ -d "$OUTPUT_DIR" ]; then
                    sudo rm -rf "$OUTPUT_DIR"
                    end_time=$(date '+%Y-%m-%d %H:%M:%S')
                    echo -e "${GREEN}${BOLD}âœ…${RESET}${GREEN} Cleanup completed | Started: $start_time | Finished: $end_time${RESET}"
                else
                    echo -e "${RED}${BOLD}âŒ Output directory not found: ${BLUE} $OUTPUT_DIR${RESET}"
                fi
                break
                ;;
            no)
                echo -e "${CYAN}All files are in: ${BLUE}$OUTPUT_DIR ${RESET} ${CYAN}â€” each in their own directory.${RESET}"
                echo -e "${CYAN}Don't forget to delete them later to save space. ðŸ™‚${RESET}"
                break
                ;;
            *)
                echo -e "${YELLOW}${BOLD}âš ï¸  Please enter 'yes' or 'no'.${RESET}"
                ;;
        esac
       
    done
    exit 0
}
# Run Script, this is the first step in the script, after FILE_CHECK runs START. 
FILE_CHECK "$1"

		# Ending Banner, this info is also displayed in the statistics.txt.
		echo -e "${BLUE}${BOLD} $(figlet "Forensics Investigation") ${RESET}"
		echo -e "${BLUE}${BOLD} $(figlet "Project: Analyzer") ${RESET}"
		
		echo ""
		echo -e "${YELLOW}===== Statistics =====${RESET}"
		echo ""
		echo -e "${BOLD}ðŸ“${RESET}${YELLOW} Output directory: ${BLUE}$OUTPUT_DIR ${RESET}"
		echo ""
		echo -e "${YELLOW}${BOLD}ðŸ“„${RESET}${YELLOW} Total files and folders:"
		tree "$OUTPUT_DIR" | tail -n 1
		echo -e "${RESET}"
		# list tools used for this report.
		echo ""
		echo -e "${YELLOW}${BOLD}ðŸ§° ${RESET}${YELLOW}Tools used during this session: ${RESET}"
		for tool in "${TOOLS_USED[@]}"; do
			echo -e "${YELLOW}   - $tool${RESET}"
		done
		echo ""
		
# Script end, show time info.
SCRIPT_END_TS=$(date +%s)
TOTAL_SECONDS=$((SCRIPT_END_TS - SCRIPT_START_TS))
echo -e "${YELLOW}${BOLD}â±ï¸ ${RESET} ${YELLOW} Script started at: ${BLUE} $(date -d @$SCRIPT_START_TS)${RESET}"
echo -e "${YELLOW}${BOLD}â±ï¸ ${RESET} ${YELLOW} Script ended at: ${BLUE} $(date -d @$SCRIPT_END_TS)${RESET}"
echo -e "${GREEN}${BOLD}â±ï¸ ${RESET} ${YELLOW} Script completed in ${BLUE} $((TOTAL_SECONDS / 60)) minutes and $((TOTAL_SECONDS % 60)) seconds.${RESET}"


function STATISTICS() {
	STAT_FILE="$OUTPUT_DIR/statistics.txt"
	# Clear file if exists
	: > "$STAT_FILE" 

	{
		figlet "Forensics Investigation"
		figlet "Project: Analyzer"
		figlet "Script Statistics"
		echo ""
		echo "===== Statistics ====="
		echo ""
		echo "ðŸ“ Output directory: $OUTPUT_DIR"
		echo ""
		echo "ðŸ“„ Total files and folders:"
		tree "$OUTPUT_DIR" | tail -n 1
		
		# list tools used for this report.
		echo ""
		echo "ðŸ§° Tools used during this session:"
		for tool in "${TOOLS_USED[@]}"; do
			echo "   - $tool"
		done
		echo ""
		
		# Network file summary.
		if [ -f "$NETWORK_FILE" ]; then
			SIZE=$(du -h "$NETWORK_FILE" | cut -f1)
			echo "âœ… Network traffic from netscan saved to: $NETWORK_FILE ($SIZE)"
		fi

		# Check for extracted pcap file.
		pcap_file=$(find "$OUTPUT_DIR/bulk_extractor_output" -type f -iname "*.pcap" 2>/dev/null | head -n 1)
		if [ -n "$pcap_file" ]; then
			filesize=$(du -h "$pcap_file" | cut -f1)
			echo "ðŸ“¡ Network traffic file detected!"
			echo "ðŸ“‚ Location: $pcap_file"
			echo "ðŸ“¦ Size: $filesize"
		fi
		echo ""
		echo ""
		if [ -n "$TOTAL_SECONDS" ]; then
			echo "â±ï¸ Script completed in $((TOTAL_SECONDS / 60)) minutes and $((TOTAL_SECONDS % 60)) seconds."
		else
			echo "â±ï¸ Script time not recorded."
		fi
		echo ""

		echo ""
		echo "===== End of Statistics ====="
	} >> "$STAT_FILE"

	# Show status and compress output
	echo -e "${YELLOW}[*] Compressing output directory. Please wait...${RESET}"
	zip -r "${OUTPUT_DIR}.zip" "$OUTPUT_DIR" > /dev/null 2>&1
	echo -e "${YELLOW}ðŸ“¦ Output directory compressed to: ${BLUE}${OUTPUT_DIR}.zip${RESET}"
}

# Create report statistics.txt & compress all files & folders.
STATISTICS
# Remove the OUTPUT_DIR and all under it after zip is already done. 
sudo rm -rf "${OUTPUT_DIR}"
# Script End.
